{"name":"ActorToConsole","type":"script","scope":"global","author":"g325YPUxaNNgCApI","img":"icons/svg/dice-target.svg","command":"const tokens = canvas.tokens.controlled;\nfor (let i = 0; i < tokens.length; i++) {\n    console.log(game.actors.get(tokens[i].document.actorId));\n}","ownership":{"default":0,"g325YPUxaNNgCApI":3},"flags":{"core":{"sourceId":"Macro.9CCDEv3NKAqG3QOu"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.288","createdTime":1665594319558,"modifiedTime":1667187834762,"lastModifiedBy":"g325YPUxaNNgCApI"},"folder":null,"sort":0,"_id":"71qjrOSoGFzpxkz4"}
{"name":"Stress","type":"script","scope":"global","author":"g325YPUxaNNgCApI","img":"icons/magic/death/undead-ghosts-trio-blue.webp","command":"//const actorIds = [\"tBmsCEZ4otbmmPcO\",\"anotherID\",\"...\"]; // for corner cases and whatever\nconst actorIds = canvas.tokens.controlled.map(t => t.actor.id);\nconst icon = \"icons/magic/death/undead-ghosts-trio-blue.webp\";\nconst label = \"Stress\";\n\nconst keys = [\n  \"system.bonuses.abilities.save\",\n  \"system.bonuses.abilities.check\",\n  \"system.bonuses.mwak.attack\",\n  \"system.bonuses.rwak.attack\",\n  \"system.bonuses.msak.attack\",\n  \"system.bonuses.rsak.attack\"\n];\nconst actorOptions = actorIds.reduce((acc, id) => {\n  const name = game.actors.get(id).name;\n  return acc + `<option value=\"${id}\">${name}</option>`;\n}, \"\");\nconst dirOptions = `\n<option value=\"-1\">Reduce Stress</option>\n<option value=\"1\">Increase Stress</option>`;\nconst content = `\n<form>\n  <div class=\"form-group\">\n    <label>Affected Actor:</laberl>\n    <div class=\"form-fields\">\n      <select id=\"target-stress-actor\">${actorOptions}</select>\n      <select id=\"stress-direction\">${dirOptions}</select>\n    </div>\n  </div>\n</form>`;\nawait Dialog.prompt({\n  title: \"Stress Config\", content, callback: (html) => {\n    const actorId = html[0].querySelector(\"#target-stress-actor\").value;\n    const dir = html[0].querySelector(\"#stress-direction\").value;\n    return updateValue(actorId, dir);\n  }\n});\n\nfunction updateValue(actorId, dir) {\n  const actor = game.actors.get(actorId);\n  const effect = actor.effects.find(e => foundry.utils.hasProperty(e, \"flags.world.stress\"));\n  const current = effect?.getFlag(\"world\", \"stress\") ?? 0;\n  //    const stress = Number(Math.max(current, 0)) + Number(dir);\n  const stress = Number(Math.max(current + Number(dir), 0));\n  const changes = keys.map(key => {\n    return { key, mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: `-${stress}` };\n  });\n  const effectData = { changes, icon, label };\n  foundry.utils.setProperty(effectData, \"flags.world.stress\", stress);\n  if (effect) return effect.update(effectData);\n  return actor.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n}","ownership":{"default":0,"g325YPUxaNNgCApI":3},"flags":{"core":{"sourceId":"Macro.dkK4qMJG7zQLkfT0"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.288","createdTime":1667051893165,"modifiedTime":1667187932266,"lastModifiedBy":"g325YPUxaNNgCApI"},"folder":null,"sort":0,"_id":"bUIwtAnVoqFQgdKV"}
{"name":"List Modules","type":"script","scope":"global","author":"npmYF618vZgxA5SD","img":"icons/svg/dice-target.svg","command":"// the console report can be copied directly into the Markdown documentation (right-click copy String contents)\n\nconst modulesActive = game.modules.filter(m => m.active);\nconst moduleReport = modulesActive.map(\n    m => ({ id: m.id, title: m.title, version: m.version })\n);\nconsole.log(modulesActive);\nconsole.log(moduleReport);\n\nlet reportString = \"\";\n\nfor (i = 0; i < modulesActive.length; i++) {\n    m = modulesActive[i];\n    reportString = `${reportString}\\n1. ${m.title} (version: ${m.version}) : [Project-URL](${m.url})`;\n}\n\nconsole.log({ reportString: reportString });","ownership":{"default":0,"npmYF618vZgxA5SD":3},"flags":{"core":{"sourceId":"Macro.11X8tUQsJgIdg9tb"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1668180229523,"modifiedTime":1668184490587,"lastModifiedBy":"npmYF618vZgxA5SD"},"folder":null,"sort":0,"_id":"j2zcAJLE4Ae5tFPU"}
{"name":"Cycle Wildcard Token","type":"script","scope":"global","author":"npmYF618vZgxA5SD","img":"icons/svg/dice-target.svg","command":"// https://github.com/krbz999/zhell-macros/blob/main/tools/token/cycle_token_wildcards.js\nconst currentImg = token.document.texture.src;\nconst actorId = token.actor.id;\nconst wildcardImages = await game.actors.get(actorId).getTokenImages();\nconst currentIndex = wildcardImages.indexOf(currentImg);\nconst next = (currentIndex + 1) === wildcardImages.length ? 0 : currentIndex + 1;\nawait token.document.update({ \"texture.src\": wildcardImages[next] });","ownership":{"default":0,"npmYF618vZgxA5SD":3},"flags":{"core":{"sourceId":"Macro.hjsPei1SwSYahJ6m"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1668177770431,"modifiedTime":1668184498110,"lastModifiedBy":"npmYF618vZgxA5SD"},"folder":null,"sort":0,"_id":"bPbwE5JCZkByg9w5"}
{"$$deleted":true,"_id":"j2zcAJLE4Ae5tFPU"}
{"name":"listActiveModules","type":"script","scope":"global","author":"npmYF618vZgxA5SD","img":"icons/svg/dice-target.svg","command":"// the console report can be copied directly into the Markdown documentation (right-click copy String contents)\n\nconst modulesActive = game.modules.filter(m => m.active);\nconst moduleReport = modulesActive.map(\n    m => ({ id: m.id, title: m.title, version: m.version })\n);\nconsole.log(modulesActive);\nconsole.log(moduleReport);\n\nlet reportString = \"\";\n\nfor (i = 0; i < modulesActive.length; i++) {\n    m = modulesActive[i];\n    reportString = `${reportString}\\n1. ${m.title} (version: ${m.version}) : [Project-URL](${m.url})`;\n}\n\nconsole.log({ reportString: reportString });","ownership":{"default":0,"npmYF618vZgxA5SD":3},"flags":{"core":{"sourceId":"Macro.JjoRX5KwFPNQdSlr"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1668016102525,"modifiedTime":1668184530058,"lastModifiedBy":"npmYF618vZgxA5SD"},"folder":null,"sort":0,"_id":"KnJ4shfO7vbi8eqg"}
{"name":"Twilight Sanctuary tHP","type":"script","scope":"global","author":"npmYF618vZgxA5SD","img":"icons/magic/light/light-lantern-lit-white.webp","command":"/* \n    icon suggestion: icons/magic/light/light-lantern-lit-white.webp\n    source: https://github.com/itteerde/fvttconfig/blob/main/tools/macros/gm/TwilightSanctuaryTakeTempHP.js\n    discussion: https://github.com/itteerde/fvttconfig/issues/29\n\n    I think I like the version where the Cleric player gets the `Effect` (that can create the `Aura` [either already or once we adopt `Effect Macro` which we'll test]) for having the `Twilight Sanctuary` active, maybe being applied by hitting the `Feature` (think we have that possibility already). All players get another `Macro` `Take Twilight Sanctuary HP` that looks for the active `Twilight Sanctuary` (everyone can read everything through code, just not save changes non-locally, so everyone can find the source in order to read their Cleric-Level), `Roll` and upgrade their own `Actor.system.attributes.hp.temp`.\n\n    We do not let the Cleric player give the temp hp as that would require socket registering and programming or warpgate in order to modify an `Actor` the `User` does have the prvileges to modify.\n*/\n\nconst macroLabel = \"Channel Divinity: Twilight Sanctuary tempHP\";\nconst sourceLabel = \"Channel Divinity: Twilight Sanctuary\";\nconst useDistance3D = true;\n\n//get the source Twilight Cleric\nconst twilightClericPCs = canvas.tokens.placeables.filter(t => {\n    if (t.actor.type !== \"character\")\n        return;\n    if (!t.actor.items.find(i => i.name === \"Twilight Domain\"))\n        return;\n    return t.actor.effects.find(e => e.label === \"Channel Divinity: Twilight Sanctuary\");\n});\nconsole.log(twilightClericPCs);\n\nif (twilightClericPCs.length === 0) {\n    ui.notifications.error(\n        `${macroLabel}, ${twilightClericPCs.length} Twilight Clerics found.`,\n        { permanent: true }\n    );\n    return;\n}\n\n// check validity of source, maybe enforce hover if it is not?\nif (twilightClericPCs.length !== 1) {\n    ui.notifications.warn(\n        `${macroLabel}, ${twilightClericPCs.length} Twilight Clerics found. Expected 1 and only 1.`,\n        { permanent: true }\n    );\n}\n\n\n// target?\nif (canvas.tokens.controlled.length !== 1) {\n    ui.notifications.error(`${macroLabel}, ${canvas.tokens.controlled.length} Actors selected. Select 1 and only 1.`, { permanent: true });\n    return;\n}\n\nif (actor.type !== \"character\") {\n    ui.notifications.error(`${macroLabel}, Actor selected is type:${actor.type}. Select a character.`);\n    return;\n}\n\nconsole.log({ target: actor, name: actor.name, id: actor._id });\n\n\n// check distance\nconst tokenSource = twilightClericPCs[0]; // this is not sound, there should be logid to chose if there are more than one.\n\nconst tokenTarget = canvas.tokens.placeables.find(t => t.actor._id === actor._id); // also not sound technically. There might be more than one Token for the same correct Actor, and not all might be in range.\nif (!tokenTarget) {\n    ui.notifications.error(`${macroLabel}, Actor context ${actor} does not match ${tokenTarget} found.`);\n    return;\n}\n\nconst cleric = tokenSource.actor;\nconst clericLevel = cleric.items.filter(i => i.type === \"class\").find(c => c.name === \"Cleric\").system.levels;\n\nconst distance = Math.round(canvas.grid.measureDistance(tokenSource, tokenTarget, { gridSpaces: true }));\nconst distance3D = Math.round(Math.sqrt(distance * distance + (tokenSource.document.elevation - tokenTarget.document.elevation) * (tokenSource.document.elevation - tokenTarget.document.elevation)));\nconsole.log({ message: \"distance\", distance: distance, distance3D: distance3D });\n\nif ((useDistance3D ? distance3D : distance) > 30) {\n    ui.notifications.warn(\n        `Distance between ${cleric.name} and ${actor.name} is ${(useDistance3D ? distance3D : distance)}. Expected distance<=30.`,\n        { permanent: true }\n    );\n\n    return;\n}\n\n// create the Roll\nconst roll = await new Roll(`1d6+${clericLevel}`, actor.getRollData()).evaluate({ async: true })\n\n// create the ChatMessage\nawait roll.toMessage({ speaker: ChatMessage.getSpeaker({ actor: cleric.name }), flavor: `getting temporary hit points by ${macroLabel} from ${cleric.name}.` });\n\nconst currentTempHP = tokenTarget.actor.system.attributes.hp.temp !== null ? tokenTarget.actor.system.attributes.hp.temp : 0;\nconst newTempHP = Math.max(roll.total, currentTempHP);\nconsole.log({ message: \"newTempHP\", temp: newTempHP });\n\nawait actor.update({ \"system.attributes.hp.temp\": newTempHP });","ownership":{"default":0,"npmYF618vZgxA5SD":3},"flags":{"core":{"sourceId":"Macro.Wi8tj7jT2lkYEcBD"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1668184550598,"modifiedTime":1668184611234,"lastModifiedBy":"npmYF618vZgxA5SD"},"folder":null,"sort":0,"_id":"ctugKIda2tJRhtdm"}
